%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{GeomAttribute Documentation}
\date{Dec 01, 2018}
\release{}
\author{Philip Whitten}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\maketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\sphinxincludegraphics{{attribute_table}.png}



A QGIS 3 plugin that shows an attribute table which includes a geometry column for any vector layer.

This plugin has the following tools:


\chapter{Geometry Attribute Table}
\label{\detokenize{geomAttribute:geometry-attribute-table}}\label{\detokenize{geomAttribute:geometryattributetable-page}}\label{\detokenize{geomAttribute::doc}}
\sphinxincludegraphics{{attribute_table}.png}


\section{Description}
\label{\detokenize{geomAttribute:description}}
An attribute table window which includes a geometry column for any vector layer.

The geometry column uses the icons shown in the table below to indicate the feature’s geometry type in descending
precedence: unknown (null); empty; point; multi-part point; line; multi-part line; polygon; and, multi-part polygon.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Icons used to represent various geometries.}\label{\detokenize{geomAttribute:id1}}\label{\detokenize{geomAttribute:geometryicon-table}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{15}{50}|\X{35}{50}|}
\hline
\sphinxstyletheadfamily 
Icon
&\sphinxstyletheadfamily 
Geometry
\\
\hline
\sphinxincludegraphics{{Empty}.png}
&
Empty geometry
\\
\hline
\sphinxincludegraphics{{Null}.png}
&
Unknown geometry
\\
\hline
\sphinxincludegraphics{{point_1x}.png}
&
Point
\\
\hline
\sphinxincludegraphics{{point_2x}.png}
&
Multi-Part Point
\\
\hline
\sphinxincludegraphics{{line_1x}.png}
&
Line
\\
\hline
\sphinxincludegraphics{{line_2x}.png}
&
Multi-Part Line
\\
\hline
\sphinxincludegraphics{{polygon_1x}.png}
&
Polygon
\\
\hline
\sphinxincludegraphics{{polygon_2x}.png}
&
Multi-Part Polygon
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{Use}
\label{\detokenize{geomAttribute:use}}
This tool works on the current active layer within QGIS.  The current layer needs to be a vector layer.  This tool will
not work on a raster layer.

Click on the vector layer in the \sphinxstyleemphasis{Layers Panel} then click on the \sphinxstyleemphasis{Geometry Attribute Table} icon \sphinxincludegraphics{{attribute_table}.png} or select
\sphinxstyleemphasis{Geometry Attribute Table} from the \sphinxstyleemphasis{Plugins} menu.


\section{Glossary}
\label{\detokenize{geomAttribute:glossary}}\begin{description}
\item[{Geometry}] \leavevmode
The shape that is associated with a feature.  In many GIS systems the a feature can only have a single geometry type,
where the type is constrained to being the same for the entire dataset.

\item[{Dataset}] \leavevmode
A table containing features.

\item[{Empty}] \leavevmode
It is known that a geometry does not exist within the feature’s domaine.  Normally only needed for attribute tables
with multiple geometry columns.

\item[{Null}] \leavevmode
The geometry is unknown.  It may or may not be empty depending on the dataset.

\end{description}


\chapter{Load Data}
\label{\detokenize{loadData:load-data}}\label{\detokenize{loadData::doc}}
The \sphinxincludegraphics{{model_data}.png} \sphinxstyleemphasis{Load Data} function creates the following QGS memory vector layers:
\begin{itemize}
\item {} 
Multi-part Lines

\item {} 
Multi-part Points

\end{itemize}

These layers are ideal to observe the utility of the {\hyperref[\detokenize{geomAttribute:geometryattributetable-page}]{\sphinxcrossref{\DUrole{std,std-ref}{Geometry Attribute Table}}}}.

The methods that create these layers are contained within the {\hyperref[\detokenize{API:modelvectorlayers-api}]{\sphinxcrossref{\DUrole{std,std-ref}{modelVectorLayers module}}}}.


\chapter{About}
\label{\detokenize{about:about}}\label{\detokenize{about::doc}}
GeomAttribute version 0.1.0.

A QGIS 3 plugin created by Philip Whitten that is licensed under the GNU General Public License v3.0.

The plugin’s repository is on \sphinxhref{https://github.com/PhilipWhitten/geomAttribute}{GitHub}.


\chapter{API}
\label{\detokenize{API:api}}\label{\detokenize{API::doc}}
The following modules are included within this plugin.  The plugin’s repository is
on \sphinxhref{https://github.com/PhilipWhitten/geomAttribute}{GitHub}.


\section{modelVectorLayers module}
\label{\detokenize{API:module-modelVectorLayers}}\label{\detokenize{API:modelvectorlayers-module}}\label{\detokenize{API:modelvectorlayers-api}}\index{modelVectorLayers (module)@\spxentry{modelVectorLayers}\spxextra{module}}
Creates vector layers as QGIS memory layers.  These layers are intended to demonstrate how the Geometry Attribute Table
plugin renders datasets that have: multi-part, single part, empty, and, null geometries.  A description of the created
layer is included with each method.
\index{createMultiLines() (in module modelVectorLayers)@\spxentry{createMultiLines()}\spxextra{in module modelVectorLayers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{API:modelVectorLayers.createMultiLines}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{modelVectorLayers.}}\sphinxbfcode{\sphinxupquote{createMultiLines}}}{\emph{layerName='Multi-Part Lines'}}{}
A geometry collection of multi-part lines and lines (single part constrained).
\begin{description}
\item[{Args:}] \leavevmode
layerName (str): The name of the layer that is loaded into QGIS.

\item[{Returns:}] \leavevmode
A memory vector layer containing features with the following geometries: 2 part multi-line; 3 part multi-line,
1 part multi-line, line, Empty multi-line, and, Null.

\end{description}

\end{fulllineitems}

\index{createMultiPoints() (in module modelVectorLayers)@\spxentry{createMultiPoints()}\spxextra{in module modelVectorLayers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{API:modelVectorLayers.createMultiPoints}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{modelVectorLayers.}}\sphinxbfcode{\sphinxupquote{createMultiPoints}}}{\emph{layerName='Multi-Part Points'}}{}
A geometry collection of multi-part points and points (single part constrained).

For an empty point, QGIS creates erroneously creates a point with the coordinates (0 0).
\begin{description}
\item[{Args:}] \leavevmode
layerName (str): The name of the layer that is loaded into QGIS.

\item[{Returns:}] \leavevmode
A memory vector layer containing features with the following geometries: 2 point multi-point; 4 point multi-point,
1 point multi-point, line, Empty multi-line, and, Null.

\end{description}

\end{fulllineitems}



\section{parseQGISGeometry module}
\label{\detokenize{API:module-parseQGISGeometry}}\label{\detokenize{API:parseqgisgeometry-module}}\label{\detokenize{API:parseqgisgeometry-api}}\index{parseQGISGeometry (module)@\spxentry{parseQGISGeometry}\spxextra{module}}
The QGIS Expression and methods in this module parse a vector’s geometry for a QGIS vector layer.
\index{geometryField() (in module parseQGISGeometry)@\spxentry{geometryField()}\spxextra{in module parseQGISGeometry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{API:parseQGISGeometry.geometryField}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{parseQGISGeometry.}}\sphinxbfcode{\sphinxupquote{geometryField}}}{\emph{feature}, \emph{parent}}{}
Creates a QGIS expression called geometryField.  This expression returns a string that represents the geometry in
the following order of decreasing precedence:
\begin{itemize}
\item {} 
Null

\item {} 
Empty

\item {} 
Well known binary type string

\end{itemize}
\begin{description}
\item[{Args:}] \leavevmode
QgsFeature

\item[{Returns:}] \leavevmode
A string that represents the QgsFeature’s geometry.

\end{description}

\end{fulllineitems}

\index{layerAddVirtualGeometryField() (in module parseQGISGeometry)@\spxentry{layerAddVirtualGeometryField()}\spxextra{in module parseQGISGeometry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{API:parseQGISGeometry.layerAddVirtualGeometryField}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{parseQGISGeometry.}}\sphinxbfcode{\sphinxupquote{layerAddVirtualGeometryField}}}{\emph{vectorLayer}}{}
Uses the \sphinxstyleemphasis{‘geometryField’} expression to provide string values that represent the feature’s geometry.  These string
values are appended to the input \sphinxstyleemphasis{vectorLayer} as a virtual field.
\begin{description}
\item[{Args:}] \leavevmode
vectorLayer (QgsVectorLayer):  A QGIS vector layer.

\end{description}

\end{fulllineitems}

\index{layerRemoveVirtualGeometryField() (in module parseQGISGeometry)@\spxentry{layerRemoveVirtualGeometryField()}\spxextra{in module parseQGISGeometry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{API:parseQGISGeometry.layerRemoveVirtualGeometryField}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{parseQGISGeometry.}}\sphinxbfcode{\sphinxupquote{layerRemoveVirtualGeometryField}}}{\emph{vectorLayer}}{}
Removes the virtual field called \sphinxstyleemphasis{‘Geometry’} from a vector layer if it exists.
\begin{description}
\item[{Args:}] \leavevmode
vectorLayer (QgsVectorLayer):  A QGIS vector layer.

\end{description}

\end{fulllineitems}

\index{layer\_review() (in module parseQGISGeometry)@\spxentry{layer\_review()}\spxextra{in module parseQGISGeometry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{API:parseQGISGeometry.layer_review}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{parseQGISGeometry.}}\sphinxbfcode{\sphinxupquote{layer\_review}}}{\emph{layer}}{}
\sphinxstylestrong{IN PROGRESS - NOT CURRENTLY USED BY PLUGIN}

Reviews any vector layer for the presence of null or empty geometries.  Provides a summary of a layer by geometry
type.
\begin{description}
\item[{Args:}] \leavevmode
vectorLayer (QgsVectorLayer):  A QGIS vector layer.

\end{description}

\end{fulllineitems}


The following modules are included in the plugin’s repository and are useful to construct the plugin from the source
scripts.


\section{zipGeomAttribute module}
\label{\detokenize{API:module-zipGeomAttribute}}\label{\detokenize{API:zipgeomattribute-module}}\index{zipGeomAttribute (module)@\spxentry{zipGeomAttribute}\spxextra{module}}
Contains methods for zipping the minimum compiled source scripts needed for this plugin to function within QGIS.  These
methods do not do any of the compilation (e.g. update docs, or, compile the QT Designer interface).
\index{installGeomAttributeFromZip() (in module zipGeomAttribute)@\spxentry{installGeomAttributeFromZip()}\spxextra{in module zipGeomAttribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{API:zipGeomAttribute.installGeomAttributeFromZip}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{zipGeomAttribute.}}\sphinxbfcode{\sphinxupquote{installGeomAttributeFromZip}}}{\emph{pluginPath}}{}
Unzips the zipped plugin folder.  An automation used for testing.
\begin{description}
\item[{Args:}] \leavevmode
pluginPath (str): The path of the plugin folder in the user’s installation of QGIS.

\end{description}

\end{fulllineitems}

\index{zipGeomAttribute() (in module zipGeomAttribute)@\spxentry{zipGeomAttribute()}\spxextra{in module zipGeomAttribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{API:zipGeomAttribute.zipGeomAttribute}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{zipGeomAttribute.}}\sphinxbfcode{\sphinxupquote{zipGeomAttribute}}}{}{}
Zips the minimum number of files needed for the plugin to be installed into QGIS

\end{fulllineitems}



\chapter{A QGIS attribute table plugin to show empty and null shapes}
\label{\detokenize{concept:a-qgis-attribute-table-plugin-to-show-empty-and-null-shapes}}\label{\detokenize{concept:concept-page}}\label{\detokenize{concept::doc}}
\sphinxstylestrong{DRAFT}


\section{Preamble}
\label{\detokenize{concept:preamble}}
I am in the closing stages of a MGIS at Penn State and needed a topic for capstone project.  What sort of topic?? I am gainfully employed as a GIS Officer at a local government bureau, but, my employer was not willing to offer a topic nor were they willing to offer open access to curious datasets.  I have a passion for maps, cartography and spatial analysis, but, previous attempts to combine my passion with requirements for academia often ended in a feeling of futility.  From my employment, I realised that my colleagues and I occasionally loose hours because some of our datasets were \sphinxstylestrong{corrupted} by \sphinxstyleemphasis{null} or empty geometries.  I also realised that I was blissfully ignorant of the concept of \sphinxstyleemphasis{null} and empty geometries as they were not included in my GIS education.  So, I wanted to learn a bit about \sphinxstyleemphasis{null} and empty geometries in the hope that I can be more capable in my employment and so that I can feed a curiosity.

The concept of a QGIS plugin that exposed \sphinxstyleemphasis{null} and empty shapes evolved quickly.  A plugin is tangible and deliverable as opposed to curiosity which is instinct and always expanding.  QGIS is the primary desktop GIS software where I work and I was keen to learn how to automate and develop QGIS for specific tasks.  In my GIS degree we had used Python to automate tasks in ArcMap, and, C\# to make apps in ArcMap, but, we had not dabbled in QGIS.  So. this project was also an adventure in QGIS scripting.

What comes next?  From this project I have learnt that much of the GIS software and the GIS community is GIS centric.  After all, to create a new record in a dataset with either QGIS or ArcMap one creates the shape of a feature, and, subsequently populates the other attributes.  To work in reverse and create the shape of a feature as the last step in a workflow is not only not conventional, but, also not trivial.  But here’s the point, whenever I have to create geospatial records I am always given a list of attributes and the shape is the last attribute to be created, the other attributes are already known and are re-entered.  Furthermore, most of the major desktop GIS packages report set operations between datasets differently to established database conventions.  I would like to work towards making QGIS and other software packages less GIS centric so that geospatial datasets become more ubiquitous and more open to other professional communities! To become less GIS centric you need to embrace the \sphinxstyleemphasis{null} and exploit the empty.


\section{Introduction}
\label{\detokenize{concept:introduction}}
A dataset is a collection of records, where each record has a defined number of elements and the data type of each
element is also defined.  The elements are commonly referred to as attributes.  For example, a dataset of street names
may consist of records have the attribute heading \sphinxstyleemphasis{“Name”} of type variable character and the character heading
\sphinxstyleemphasis{“Street Type”} of type street type.  In this example, street types may consist of the values
\sphinxstyleemphasis{(‘Lane’, ‘Road’, ‘Street’, ‘’)}.  The first three of the values \sphinxstyleemphasis{‘Lane’}, \sphinxstyleemphasis{‘Road’} and \sphinxstyleemphasis{‘Street’} are obvious \textendash{} but what about
the last value of \sphinxstyleemphasis{‘’}?  \sphinxstylestrong{‘’ is a deliberate empty set of character values!}  In our world there are many streets that
have no type, and, indeed there are many that have no name.  Here, the use of an empty set of characters, or ‘’,
indicates that the Street Type attribute has no type, not that the type is unknown (null).

Geospatial datasets contain one or more values that refer to a location on earth.  For the majority of geospatial
datasets, the location consists of one or more points, lines and/or polygons that are referenced to a coordinate system
that is a projection of the earth’s surface.

For the purposes of this project, any dataset element type that stores the geospatial shape with respect to a referenced coordinate system is referred to as a geometry.  Any empty geometry element is simply a geometry that doesn’t have a shape.

In many enterprises geospatial datasets are contained within enterprise databases where frequently the same brand of enterprise database is used elsewhere within the same enterprise to contain non-spatial datasets.  For example, a local government office may use one or more MicroSoft SQL Server installations (MS SQL) as a dataset repository for: a content management system; a customer relationship management system; a land management system; an asset management system; and, a GIS system.

QGIS \sphinxcite{concept:id39} is a computer program that among other things is used to view, create and edit the geometry elements within geospatial datasets.  For many dataformats QGIS  QGIS does not: Pass null and empty geometry elements equivalently for different data storage formats; does not show directly show which records within a dataset have \sphinxstyleemphasis{null} or empty geometry elements; and, does not always process null and empty geometry elements as specified by standards.

This project aims to create a QGIS plugin that illuminates null and empty geometry elements in geospatial datasets.


\section{Background}
\label{\detokenize{concept:background}}

\subsection{Relational Datasets}
\label{\detokenize{concept:relational-datasets}}

\subsubsection{Set}
\label{\detokenize{concept:set}}
A set is a collection of distinct objects.  For example, a box of apples is a set of apples, and, the set of countries in North America consists of Canada,  United States of America, and, Mexico.  By convention, sets are symbolized by enclosing within curly brackets.  Hence:
\begin{equation*}
\begin{split}North\ American\ Countries = \{Canada, United\ States\ of\ America, Mexico\}\end{split}
\end{equation*}
A dataset is any set where each element is restricted to one data type and where each element belongs to the same universal set.


\subsubsection{Relational Dataset}
\label{\detokenize{concept:relational-dataset}}\begin{description}
\item[{A relational dataset is a collection of sets where:}] \leavevmode\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
The number of objects (elements) in each set is the same.

\item {} 
A one to one relationship exists between elements of different sets.

\end{enumerate}

\end{description}

An example relational dataset showing the country name, country abbreviation and country population for the countries in North America is shown in \hyperref[\detokenize{concept:tablena-simple}]{Table \ref{\detokenize{concept:tablena-simple}}}.  This relational dataset comprises of the three sets: a set of country names; a set of abbreviations; and, a set of country populations.  A one to one relationship exists between the elements for each of these three sets.  Hence, the country with the name of \sphinxstyleemphasis{Canada} has a one to one relationship with the country abbreviation \sphinxstyleemphasis{CAN} and the country population \sphinxstyleemphasis{3563000}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Example of a dataset of Countries in North America.}\label{\detokenize{concept:id40}}\label{\detokenize{concept:tablena-simple}}
\sphinxaftercaption
\begin{tabular}[t]{|*{3}{\X{1}{3}|}}
\hline
\sphinxstyletheadfamily 
\begin{DUlineblock}{0em}
\item[] Country Name
\item[] (letters and spaces)
\end{DUlineblock}
&\sphinxstyletheadfamily 
\begin{DUlineblock}{0em}
\item[] Abbreviation
\item[] (upper case letters)
\end{DUlineblock}
&\sphinxstyletheadfamily 
\begin{DUlineblock}{0em}
\item[] Population
\item[] (integer)
\end{DUlineblock}
\\
\hline
Canada
&
CAN
&
3563000
\\
\hline
United States of America
&
USA
&
32663000
\\
\hline
Mexico
&
MEX
&
12458000
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

Essential to any set is a definition or description of what type of objects can be a member.  For example, an apple which is a valid type of the set of fruit can’t be a member of a set of countries.  For any dataset, both the data type and additional constraints are often used together define the universal set.  For example, the data type for \sphinxstyleemphasis{Country Name} in \hyperref[\detokenize{concept:tablena-simple}]{Table \ref{\detokenize{concept:tablena-simple}}} is any combination of letters and spaces, whilst the data type for \sphinxstyleemphasis{Abbreviation} is any combination of 3 upper case letters.

Although a \sphinxstyleemphasis{relational dataset} consists of multiple sets of data where the elements of each set are related, it is ubiquitously referred to as a \sphinxstylestrong{dataset}.


\subsubsection{Geospatial Dataset}
\label{\detokenize{concept:geospatial-dataset}}
A geospatial dataset refers to any dataset where one or more of the composite sets refer to a location on the earth’s surface.  This project is only concerned with those geospatial datasets where the location on the earth’s surface is represented by one or more points, lines or polygons that are located by coordinates and stored as vectors.  These points, lines and polygons are collectively referred to as shapes or geometries %
\begin{footnote}[5]\sphinxAtStartFootnote
For SQL relational databases, the term geometry is restricted to those shapes that are located by cartesian coordinates.
%
\end{footnote}.

A vector geospatial dataset is a subtype of geospatial dataset where the geospatial sets can be located graphically on the earths surface by the application of coordinates.  This project is only concerned with vector geospatial datasets.


\subsubsection{Geometry data types}
\label{\detokenize{concept:geometry-data-types}}
All datasets contain some restriction on the type of data each constituent set may contain.  From a software perspective, a restriction of type is essential for minimizing both the storage size of the dataset and the response time for a dataset query.  Analagous to specific data types for storage of numbers, text or dates there is one or more data types specifically used for the storage of geospatial geometries.  Similarly, just as there are often specific data types of signed and unsigned integers, float, and, decimal numbers there are also specific data types for different types of geometries, with the type often referring to how the geometry is constructed.

For any dataset software the geometry data types that are availabe for use can be shown schematically as a hierarchy like the one shown in \hyperref[\detokenize{concept:figuregeomtypei}]{Fig.\@ \ref{\detokenize{concept:figuregeomtypei}}}.  Within this hierarchy, the possible data types are described by the labels in the boxes.  Essential to all such hierarchy’s, a set of data of a declared type may consist of any type below it on the hierarchy.  Hence, if a set of data has a declared type of \sphinxstyleemphasis{Geometry Collection} then any data element within it may consist of \sphinxstyleemphasis{Geometry Collection}, \sphinxstyleemphasis{Multi-Point}, “Multi-Curve*, \sphinxstyleemphasis{Multi-Line}, \sphinxstyleemphasis{Multi-Surface}, and, \sphinxstyleemphasis{Multi-Polygon}.  Similarly, if a set of data has a declared type of \sphinxstyleemphasis{Point} than it may not contain a \sphinxstyleemphasis{Polygon} nor a \sphinxstyleemphasis{Line}.

The single part constrained geometry subtypes in the lower part of \hyperref[\detokenize{concept:figuregeomtypei}]{Fig.\@ \ref{\detokenize{concept:figuregeomtypei}}} are referred to as \sphinxstyleemphasis{Primitive Types} and must contain only one single part geometry per set element.  In contrast, the Multiple Part geometries may consist of one \sphinxstyleemphasis{or} many parts per feature.  For example, a feature of the \sphinxstyleemphasis{“Multi-Point”} geometry sub type may have one point, no points or multiple points. Another characteristic of the single part primitive types is that the \sphinxstyleemphasis{Line} and \sphinxstyleemphasis{Polygon} subtypes may only exist of straight line segments between coordinates.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{geomTypeSQL}.png}
\caption{GIS Geometry subtype hierarchy.  Adapted from \sphinxcite{concept:iso19125-2}.  The more conventional term \sphinxstyleemphasis{“LineString”} that is used in the QGIS API and \sphinxcite{concept:iso19125-2} is replaced here with \sphinxstyleemphasis{“Line”} for clarity.}\label{\detokenize{concept:id41}}\label{\detokenize{concept:figuregeomtypei}}\end{figure}

In reality there may be many more geometry subtypes than the simplified hierarchy shown in \hyperref[\detokenize{concept:figuregeomtypei}]{Fig.\@ \ref{\detokenize{concept:figuregeomtypei}}}.  For example, some common additional subtypes for datasets are created for sets of geometries that incorporate elevation data, or, for lines that are constructed from curves as opposed to straight line segments.

Many GIS data format standards, and, many GIS software have a geometry subtype hierarchy that is \sphinxstylestrong{similar} with \hyperref[\detokenize{concept:figuregeomtypei}]{Fig.\@ \ref{\detokenize{concept:figuregeomtypei}}}.  Within a GIS dataset, geometry objects there are several geometry subtypes, with the main ones without elevation are shown in \hyperref[\detokenize{concept:figuregeomtypei}]{Fig.\@ \ref{\detokenize{concept:figuregeomtypei}}}.  Schematically, this hierarchy of geometry subtypes is replicated by the \sphinxhref{https://qgis.org/api/classQgsAbstractGeometry.html}{inheritance diagram for QgsAbstractGeometry} \sphinxcite{concept:qgsabstractgeometry}.


\subsubsection{Geometry data values}
\label{\detokenize{concept:geometry-data-values}}
For any data type there exists a universal set of valid values.  For example, a set of birthday dates must be restricted to valid dates.  For example, a birthday on the 30th of February is not valid as the 30th of February is not part of the universal set of dates.  Similarly, a valid geometry needs to be located within the boundaries of the coordinate system that it is referenced to.  \sphinxstylestrong{Empty} and \sphinxstylestrong{null} are two values that may be part of any set of data and could be fairly described as being:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Controversial

\item {} 
Miss-understood

\item {} 
Best avoided

\end{enumerate}


\paragraph{Empty}
\label{\detokenize{concept:empty}}
A box of apples can be described as a set of apples.  A empty Apple box is an empty set of apples.  An empty geometry element is a geometry that has no coordinates.  Whether an empty element is a valid member of a set depends on the context.  For example, if a study of chickens hatching from eggs recorded the date that each chicken hatches for a set of 10 eggs than the hatch date element is of the hatch date set is empty before the chicken hatches.  It is \sphinxstyleemphasis{known} that the chicken has not hatched.

A most useful function of any empty set including an empty geometry is that they are a place holder for when it is \sphinxstyleemphasis{known} that an element does not exist.  For example, consider the intersection of the Blue Crosses and the Red Circles with the two squares shown in \hyperref[\detokenize{concept:figuresquarepoint}]{Fig.\@ \ref{\detokenize{concept:figuresquarepoint}}}.  Now, the Blue Crosses B1 and B2 both intersect the Left square, and, the Blue Cross B3 intersects the Right square.  The intersections of the Squares and Blue Crosses, and the Squares with Red Circles are summarized by the datasets shown in \hyperref[\detokenize{concept:tableiiia}]{Table \ref{\detokenize{concept:tableiiia}}} and \hyperref[\detokenize{concept:tableiiib}]{Table \ref{\detokenize{concept:tableiiib}}}.  As shown in  \hyperref[\detokenize{concept:tableiiia}]{Table \ref{\detokenize{concept:tableiiia}}} the \sphinxstyleemphasis{Left Square} intersects with the \sphinxstyleemphasis{Blue Crosses} \sphinxstyleemphasis{B1} and \sphinxstyleemphasis{B2} which are represented as a subset \sphinxstyleemphasis{\{B1, B2\}}.  Similarly, it is reported in \hyperref[\detokenize{concept:tableiiib}]{Table \ref{\detokenize{concept:tableiiib}}} that the \sphinxstyleemphasis{Left square} intersects the subset of \sphinxstyleemphasis{Red Circles} \sphinxstyleemphasis{\{R1\}}.  In contrast, also in \hyperref[\detokenize{concept:tableiiib}]{Table \ref{\detokenize{concept:tableiiib}}} it is shown that the \sphinxstyleemphasis{Left square} does not intersect with any \sphinxstyleemphasis{Red Circles} as shown by the empty set \sphinxstyleemphasis{\{ \}}.  Here the empty set \sphinxstyleemphasis{\{ \}} shows that it is known that no intersection occurs.  The reporting of those combinations where intersections are known to not occur as shown  \hyperref[\detokenize{concept:tableiiib}]{Table \ref{\detokenize{concept:tableiiib}}} follows the convention used by most SQL type relational databases for all set intersections regardless of whether they are geospatial or not.  In contrast, the convention for many GIS desktop software including QGIS and ArcGIS is to only show those combinations where intersections are known to occur, hence, \hyperref[\detokenize{concept:tableiiib}]{Table \ref{\detokenize{concept:tableiiib}}} would be reported as \hyperref[\detokenize{concept:tableiiic}]{Table \ref{\detokenize{concept:tableiiic}}} by QGIS.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{squaresAndPoints}.png}
\caption{The location of blue crosses and red circles in the “Left Square” and the “Right Square”.}\label{\detokenize{concept:id42}}\label{\detokenize{concept:figuresquarepoint}}\end{figure}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{The intersection of the the \sphinxstyleemphasis{Squares} and the \sphinxstyleemphasis{Blue Crosses}.}\label{\detokenize{concept:id43}}\label{\detokenize{concept:tableiiia}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Square
&\sphinxstyletheadfamily 
Blue Crosses
\\
\hline
Left square
&
\{B1, B2\}
\\
\hline
Right square
&
\{B3\}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{The intersection of the the \sphinxstyleemphasis{Squares} and the \sphinxstyleemphasis{Red Circles}.}\label{\detokenize{concept:id44}}\label{\detokenize{concept:tableiiib}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Square
&\sphinxstyletheadfamily 
Red Circles
\\
\hline
Left square
&
\{R1\}
\\
\hline
Right square
&
\{  \}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{The intersection of the the \sphinxstyleemphasis{Squares} and the \sphinxstyleemphasis{Red Circles} as shown by QGIS.}\label{\detokenize{concept:id45}}\label{\detokenize{concept:tableiiic}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Square
&\sphinxstyletheadfamily 
Red Circles
\\
\hline
Left square
&
\{R1\}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The real utility of empty geometry values is realised when the intersection of all the squares and both types of points (\sphinxstyleemphasis{Red Circles} and \sphinxstyleemphasis{Blue Crosses}) are collated in one dataset as shown in \hyperref[\detokenize{concept:tableiii}]{Table \ref{\detokenize{concept:tableiii}}} as opposed to  \hyperref[\detokenize{concept:tableiiid}]{Table \ref{\detokenize{concept:tableiiid}}}.  By using the empty set \sphinxstyleemphasis{\{ \}} as a place holder for the known non-intersection of \sphinxstyleemphasis{Red Circles} with the \sphinxstyleemphasis{Right square} the sets of \sphinxstyleemphasis{Blue Crosses} and \sphinxstyleemphasis{Red Circles} are maintained as seperate columns.  Although this approach is efficient and intuitive it is not suitable when there is a large number of point types as the number of columns has a linear relationship to the numbs of points.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{The intersection of all point types and the squares.  Note that the sets each point type are still maintained as individual columns.  This approach is not feasible for a large number of point types as there would be too many columns.}\label{\detokenize{concept:id46}}\label{\detokenize{concept:tableiii}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxmultirow{2}{1}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
\sphinxstyletheadfamily Square
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{3}}
\sphinxstyletheadfamily Point type
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\cline{2-3}\sphinxtablestrut{1}&\sphinxstyletheadfamily 
Blue Crosses
&\sphinxstyletheadfamily 
Red Circles
\\
\hline
Left square
&
\{B1, B2\}
&
\{R1\}
\\
\hline
Right square
&
\{B3\}
&
\{ \}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{The intersection of all point types and the squares.}\label{\detokenize{concept:id47}}\label{\detokenize{concept:tableiiid}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Square
&\sphinxstyletheadfamily 
Point type
&\sphinxstyletheadfamily 
Geometry
\\
\hline
Left square
&
Blue Crosses
&
\{B1, B2\}
\\
\hline
Right square
&
Blue Crosses
&
\{B3\}
\\
\hline
Left square
&
Red Circles
&
\{R1\}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Null}
\label{\detokenize{concept:null}}
\sphinxstylestrong{Null} is the most common value (element) recorded many disciplines and software formats for \sphinxstyleemphasis{unknown} data values %
\begin{footnote}[6]\sphinxAtStartFootnote
Python uses \sphinxstyleemphasis{None} instead of \sphinxstyleemphasis{null}, but, PyQT uses \sphinxstyleemphasis{NULL} as a QVariant, so, PyQGIS script may have a mixture of \sphinxstyleemphasis{None} and \sphinxstyleemphasis{NULL} depending on the origin of the classes in use.
%
\end{footnote}.  For example, if a study of chickens hatching from eggs recorded the hatch date of each chicken hatching for a set of 10 eggs than the hatch date element of the hatch date set is \sphinxstyleemphasis{null} (unknown) if the hatch date was not recorded.  Strictly speaking a \sphinxstyleemphasis{null} hatch date can be any value from the universal set of hath dates including \sphinxstyleemphasis{Empty} allowing for eggs that never hatched.

The most useful feature of \sphinxstyleemphasis{null} values is that they enable incomplete datasets.  For example, consider the dataset of the set of Blue Crosses \{B1, B2, B3, B4\}  and the set of Squares shown in \hyperref[\detokenize{concept:figuresquarenull}]{Fig.\@ \ref{\detokenize{concept:figuresquarenull}}} and described by the dataset \hyperref[\detokenize{concept:tableiiie}]{Table \ref{\detokenize{concept:tableiiie}}}.  Whilst the it is known that the crosses \{B1, B2, B4\} are both located in the \sphinxstyleemphasis{Left square}, the coordinates of B4 are unknown and it is consequently absent from  \hyperref[\detokenize{concept:figuresquarenull}]{Fig.\@ \ref{\detokenize{concept:figuresquarenull}}}.  Datasets like \hyperref[\detokenize{concept:tableiiie}]{Table \ref{\detokenize{concept:tableiiie}}} are common and can stem from requests to georeference existing datasets where the georeferencing is incomplete.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{squaresAndPointsNull}.png}
\caption{The location of the \sphinxstyleemphasis{Blue Crosses \{B1, B2, B3\}} with respect to two squares.  The location of the \sphinxstyleemphasis{Blue cross B4} is in the Left sqaure, but, it’s coordinates are unknown.}\label{\detokenize{concept:id48}}\label{\detokenize{concept:figuresquarenull}}\end{figure}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{A dataset that displays the relationships between the Squares, Blue Crosses, and, the coordinates for the Blue Crosses.}\label{\detokenize{concept:id49}}\label{\detokenize{concept:tableiiie}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Square
&\sphinxstyletheadfamily 
Blue Cross
&\sphinxstyletheadfamily 
Coordinates
\\
\hline
Left square
&
B1
&
(1, 1)
\\
\hline
Left square
&
B2
&
(2, 2)
\\
\hline
Right square
&
B3
&
(4, 2)
\\
\hline
Left square
&
B4
&
\sphinxstyleemphasis{null}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Using joins to eliminate null}
\label{\detokenize{concept:using-joins-to-eliminate-null}}
Many GIS datasets do not allow \sphinxstyleemphasis{null} geometries.  Having a dataset constraint that prevents the recording of \sphinxstyleemphasis{null} geometries does not imply that the geometries are all known, it only means that the dataset can’t have a \sphinxstyleemphasis{null} geometry.  The prevention of \sphinxstyleemphasis{null} geometries without knowing all of the geometries is achieved by using multiple datasets that include a geometry only dataset that has a relationship with a non-geometry dataset as shown in \hyperref[\detokenize{concept:figurejoinedcrosses}]{Fig.\@ \ref{\detokenize{concept:figurejoinedcrosses}}}.  The relationship is typically achieved by the use of a \sphinxstylestrong{key} that is used in all datasets to distinguish each record.  Joins refer this process of forming a dataset from multiple datasets by the use of a relationship.  The dataset shown in \hyperref[\detokenize{concept:tableiiie}]{Table \ref{\detokenize{concept:tableiiie}}} can be created from the datasets shown in \hyperref[\detokenize{concept:figurejoinedcrosses}]{Fig.\@ \ref{\detokenize{concept:figurejoinedcrosses}}} by using an \sphinxstyleemphasis{outer join}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{CrossesWithoutNull}.png}
\caption{The same data records as \hyperref[\detokenize{concept:tableiiie}]{Table \ref{\detokenize{concept:tableiiie}}} recorded as two separate datasets where a \sphinxstyleemphasis{null} \sphinxstyleemphasis{Coordinates} data value is not permitted.  The \sphinxstyleemphasis{Blue Crosses} key is used to create a relationship between the two datasets that is symbolised by the grey dashed lines.}\label{\detokenize{concept:id50}}\label{\detokenize{concept:figurejoinedcrosses}}\end{figure}


\paragraph{Reasons for preventing null geometries}
\label{\detokenize{concept:reasons-for-preventing-null-geometries}}
The reasons for preventing null geometries include: it’s keeps GIS feature creation simple: one can’t map \sphinxstyleemphasis{null}; they permit the geometry value to be a variable; and, it keeps logic based algorithms simple.

For QGIS and many desktop GIS systems, records are created by drawing the geometry and subsequently entering the other data values.  This geospatial geometry centered approach intuitively keeps the related computer programming simple in comparison to an approach that would allow a user to enter any of the data values including the geometry in the sequence that they choose.

There is no accepted universal approach to mapping a \sphinxstyleemphasis{null} geometry.  It is obvious that if a geometry is \sphinxstyleemphasis{null} then using a defined symbol at a single location is a miss-representation.  There is active research into approaches for mapping the unknown.

The use of a geometry specific dataset enables geometry to be a variable.  For example, take the Blue Cross B1.  This Blue Cross may represent a boat in a sea.  Hence, at different points in time, B1 may have different coordinates (\hyperref[\detokenize{concept:tableiiif}]{Table \ref{\detokenize{concept:tableiiif}}}).  Most geospatial datasets have geometries that are variable as our technology for recording and knowing location is improving.  For example, an allotment of land may be static as it is relative to reference points, but, the mapped location and hence the recorded geometry for the allotment of land will change as the location of the reference points is refined to a higher accuracy.  Whether a dataset owner needs to keep a record of changes to a geometry is a question that is beyond the scope of this discussion.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{The coordinates of the Blue Crosses for yesterday and today.}\label{\detokenize{concept:id51}}\label{\detokenize{concept:tableiiif}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Blue Cross
&\sphinxstyletheadfamily 
Coordinates
&\sphinxstyletheadfamily 
Date
\\
\hline
B1
&
(1, 1)
&
Today
\\
\hline
B1
&
(2, 2)
&
Yesterday
\\
\hline
B2
&
(2, 2)
&
Today
\\
\hline
B2
&
(1, 2)
&
Yesterday
\\
\hline
B3
&
(4, 2)
&
Today
\\
\hline
B3
&
(4, 1)
&
Yesterday
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Whether a dataset allows \sphinxstyleemphasis{null} values or not directly affects the type of logic applied to the dataset for set operations.  Boolean logic, also referred to as two value logic allows only for True or False.  Boolean logic has no value when the answer is unknown.  When null values are permitted, three value logic is required whenever one of the answers is unknown.  Consider the intersection based of the squares with the blue crosses shown in  \hyperref[\detokenize{concept:tableiiie}]{Table \ref{\detokenize{concept:tableiiie}}} based on the coordinates of the Blue Crosses with and without the Blue Cross B4 as shown in \hyperref[\detokenize{concept:tableiiig}]{Table \ref{\detokenize{concept:tableiiig}}}.  For \{B1, B2\} it is True that they intersect the Left square, whilst it is also True that \{B3\} does not intersect the same square, however, it is null (unknown) whether \{B4\} intersects the Left Square.  Compounding the implementation of Three value logic is the fact that different database platforms implement three value logic differently leading to widespread avoidance of three value logic regardless of whether the data type is geometry or something more generic like an integer.  In summary, even when \sphinxstyleemphasis{null} values are permitted in datasets, the records associated with them are typically excluded from set operations.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{The intersection of the squares with the subsets \{B1, B2, B3\} and \{B1, B2, B3, and B4\} based on the coordinates as shown in \hyperref[\detokenize{concept:tableiiie}]{Table \ref{\detokenize{concept:tableiiie}}}.}\label{\detokenize{concept:id52}}\label{\detokenize{concept:tableiiig}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxmultirow{3}{1}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
\sphinxstyletheadfamily Square
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{3}}
\sphinxstyletheadfamily Intersection with the subset
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\cline{2-3}\sphinxtablestrut{1}&\sphinxstyletheadfamily 
\{B1, B2, B3\}
&\sphinxstyletheadfamily 
\{B1, B2, B3, B4\}
\\
\cline{2-3}\sphinxtablestrut{1}&\sphinxstyletheadfamily 
Boolean logic
&\sphinxstyletheadfamily 
Three value logic
\\
\hline
Left square
&
\{B1, B2\}
&
\{B1, B2, null-B4\}
\\
\hline
Right square
&
\{B3\}
&
\{B3, null-B4\}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Although beyond the scope of this project, it is noted that although Boolean logic is applied the same in the majority of relational databases there is known diversity in the application for three value logic.
In the described road name example, it was noted that the road ‘Rd2’ has no name.  If the ‘Road Name’ attribute is
considered to be a set of characters, then, the set of characters for Rd2’s ‘Road Name’ is empty.  By definition, an
empty set is a set that has no members.  By deduction, an empty set or an empty value is not a \sphinxstyleemphasis{null} value.  Hence, it
is \sphinxstylestrong{known} that road ‘Rd2’ does not have a name, but, it is \sphinxstylestrong{unknown} whether road ‘Rd3’ has a name or not.


\paragraph{Reasons for allowing null geometries}
\label{\detokenize{concept:reasons-for-allowing-null-geometries}}
Although the majority of GIS systems do not promote the use of null geometry data values, there are several reasons why they should be adopted: they force the adoption of geospatial datasets by enterprise databases; they illuminate the unknown; and, they facilitate a simpler dataset structure.

The forced adoption of geospatial datasets by enterprise databases is the most compelling reason to adopt null geometry values.  For example, consider a commercial database used for rates at a local government.  The current approach of most databases for rates is to mimic \hyperref[\detokenize{concept:figurejoinedcrosses}]{Fig.\@ \ref{\detokenize{concept:figurejoinedcrosses}}} where the tables for the land registry are maintained within a land registry database, and, the tables for the georeferenced land allotments are in a GIS database and these databases are joined.  This approach facilitates bureacracies where seperate teams of people maintain each database, and, where the land registry database does not adopt spatial functionality as the data is located in a separate database.  Whilst using a separate GIS database allows the local government to develop a custom GIS system, it comes at a cost of minimal inbuilt spatial capability.

Allowing null geometries promotes facilities the use of geospatial datasets in enterprise databases.  Does not hide the unknown.  Keeps a simple dataset structure with fewer datasets.

By way of definition, an empty geometry is a geometry data type that has no members \sphinxcite{concept:ogc2010}.  The empty geometry
value is a placeholder that illuminates that it is known that no geometry exists.  An empty geometry is a known value,
whereas a null geometry is an unknown value that may or may not be empty.

The use of a lookup table to contain geometry datasets in comparison to storing the geometry datasets in a single table with other relevant attributes requires an additional table to be created and a lookup key to be maintained.  A major advantage of the lookup table approach is that one can maintain the main non-geometry dataset in one enterprise database system that is not geospatially enabled, and, the ancillary geometry dataset in a geospatially enabled database.  Another advantage is that an organisation can use a single piece of geospatial software to maintain the geometry data that is associated with data in several different enterprise databases.  In this way, geospatial capability can be retrofitted to an enterprise database.  A major disadvantage of the lookup table approach is the requirement for the documentation of database schema for users to maintain the lookup key and to perform database queries that include spatial and non-spatial attributes.

Empty values and their use are much more complicated to resolve relative to null values.  Prohibiting empty values has
two major software design ramifications: Datasets are unable to contain multiple shape attributes; and, false set operations have to be removed by a selection.


\subsection{Parsing data by QGIS data Providers}
\label{\detokenize{concept:parsing-data-by-qgis-data-providers}}
QGIS parses data to and from many data formats without requiring importing or exporting to or from a common data format.  The intent of this data parsing is that a user may analyse data stored in different formats with a common user interface.  A key component of any GIS record is a geospatial geometry data type which could be stored in an infinite number of ways.  Fortunately, there are international standards \sphinxcite{concept:iso19125-2} that describe the geospatial geometry data type and subtypes, and, there is some consistency across most data formats.

Although different GIS data formats have \sphinxstylestrong{similar} subtype hierarchy’s, they are not the same.  For example, many different SQL databases that adopt elements of ISO19125-2 \sphinxcite{concept:iso19125-2} including PostGis and MS SQL by default have a \sphinxstyleemphasis{Geometry} subtype %
\begin{footnote}[4]\sphinxAtStartFootnote
In many QSL databases the hierarchy separates all geometry types that employ cartesian coordinates from those that employ geographic coordinates.
%
\end{footnote}. Consequently, without further constraints in their native environment one can choose any subtype shown in \hyperref[\detokenize{concept:figuregeomtypei}]{Fig.\@ \ref{\detokenize{concept:figuregeomtypei}}} for any record.  In comparison, the \sphinxstyleemphasis{Geometry} subtype equivalent in the QGIS data type inheritance diagram \sphinxcite{concept:qgsabstractgeometry} has the title \sphinxstyleemphasis{“QgsAbstractGeometry”} where the \sphinxstyleemphasis{Abstract} keyword tell us that this datatype can’t be created by itself, only it’s children can be created.  To emphasize, parsing data for different data formats but maintaining a uniform user interface is a Pandora’s box when the data types or subtypes have different hierarchy’s of data subtypes.

With the understanding that different data formats have different geometry hierarchy’s it is expected that QGIS needs to make adjustments on the fly.
.the This parsing is silent and without experience errors may be introduced into datasets.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Feature geometry changes when exporting a QGIS Multi-Line memory layer.}\label{\detokenize{concept:id53}}\label{\detokenize{concept:tablemultiline}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Original
&\sphinxstyletheadfamily 
Geopackage
&\sphinxstyletheadfamily 
Shapefile
&\sphinxstyletheadfamily 
Spatialite
&\sphinxstyletheadfamily 
PostGis
&\sphinxstyletheadfamily 
MS SQL
\\
\hline
Multi-Line
&
Multi-Line
&
Multi-Line
&
Multi-Line
&
Multi-Line
&
Multi-Line
\\
\hline
Line
&
\sphinxstyleemphasis{Multi-Line}
&
\sphinxstyleemphasis{Multi-Line}
&
\sphinxstyleemphasis{Multi-Line}
&
Line
&
Line
\\
\hline
Empty
&
Empty
&
\sphinxstyleemphasis{null}
&
Empty
&
Empty
&
\sphinxstyleemphasis{null}
\\
\hline
\sphinxstyleemphasis{null}
&
Empty
&
\sphinxstyleemphasis{null}
&
Empty
&
\sphinxstyleemphasis{null}
&
\sphinxstyleemphasis{null}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

For several dataproviders including QGIS memory layer, PostGIS and MicroSoft SQL Server QGIS employs a subtype hierarchy shown by \hyperref[\detokenize{concept:figuregeomtypeii}]{Fig.\@ \ref{\detokenize{concept:figuregeomtypeii}}}.  Hence for some dataproviders, by default, QGIS creates a new one part line in a dataset of the \sphinxstyleemphasis{“Multi-Line”} subtype as a Line and not a \sphinxstyleemphasis{“Multi-Line”}.  The insertion of a \sphinxstyleemphasis{“Line”} geometry subtype into a \sphinxstyleemphasis{“Multi-Line”} geometry subtype dataset is readily demonstrated by python script using the QGIS API:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{qgis.core} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{layerMulti}\PYG{o}{=}\PYG{n}{QgsVectorLayer}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MultiLineString?crs=epsg:4326\PYGZam{}field=ID:string}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{memory}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{providerMulti}\PYG{o}{=}\PYG{n}{layerMulti}\PYG{o}{.}\PYG{n}{dataProvider}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{recordWrite} \PYG{o}{=} \PYG{n}{QgsFeature}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{recordWrite}\PYG{o}{.}\PYG{n}{setAttributes}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{recordWrite}\PYG{o}{.}\PYG{n}{setGeometry}\PYG{p}{(}\PYG{n}{QgsGeometry}\PYG{o}{.}\PYG{n}{fromWkt}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LINESTRING (1 1, 6 1)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{providerMulti}\PYG{o}{.}\PYG{n}{addFeature}\PYG{p}{(}\PYG{n}{recordWrite}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{recordRead} \PYG{o}{=} \PYG{n}{layerMulti}\PYG{o}{.}\PYG{n}{getFeature}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{QgsWkbTypes}\PYG{o}{.}\PYG{n}{displayString}\PYG{p}{(}\PYG{n}{recordRead}\PYG{o}{.}\PYG{n}{geometry}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{wkbType}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{LineString}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{QgsWkbTypes}\PYG{o}{.}\PYG{n}{displayString}\PYG{p}{(}\PYG{n}{layerMulti}\PYG{o}{.}\PYG{n}{dataProvider}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{wkbType}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{MultiLineString}
\end{sphinxVerbatim}

More worringly, as shown in the next python script, the reverse is also possible.  One may add a feature with a \sphinxstyleemphasis{Multi-Line} geometry sub-type to a \sphinxstyleemphasis{Line} dataset.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{qgis.core} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{layerSingle}\PYG{o}{=}\PYG{n}{QgsVectorLayer}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LineString?crs=epsg:4326\PYGZam{}field=ID:string}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{memory}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{providerSingle} \PYG{o}{=} \PYG{n}{layerSingle}\PYG{o}{.}\PYG{n}{dataProvider}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{recordWrite} \PYG{o}{=} \PYG{n}{QgsFeature}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{recordWrite}\PYG{o}{.}\PYG{n}{setAttributes}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{recordWrite}\PYG{o}{.}\PYG{n}{setGeometry}\PYG{p}{(}\PYG{n}{QgsGeometry}\PYG{o}{.}\PYG{n}{fromWkt}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MULTILINESTRING ((1 1, 6 1))}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{providerSingle}\PYG{o}{.}\PYG{n}{addFeature}\PYG{p}{(}\PYG{n}{recordWrite}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{recordRead} \PYG{o}{=} \PYG{n}{layerSingle}\PYG{o}{.}\PYG{n}{getFeature}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{QgsWkbTypes}\PYG{o}{.}\PYG{n}{displayString}\PYG{p}{(}\PYG{n}{recordRead}\PYG{o}{.}\PYG{n}{geometry}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{wkbType}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{MultiLineString}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{QgsWkbTypes}\PYG{o}{.}\PYG{n}{displayString}\PYG{p}{(}\PYG{n}{layerSingle}\PYG{o}{.}\PYG{n}{dataProvider}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{wkbType}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{LineString}
\end{sphinxVerbatim}

Fortunately with QGIS you can’t insert a \sphinxstyleemphasis{Point} into a \sphinxstyleemphasis{Line} dataset, or, otherwise mix geometry sub-types of different dimensionality.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{qgis.core} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{layerSingle}\PYG{o}{=}\PYG{n}{QgsVectorLayer}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LineString?crs=epsg:4326\PYGZam{}field=ID:string}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{memory}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{providerSingle} \PYG{o}{=} \PYG{n}{layerSingle}\PYG{o}{.}\PYG{n}{dataProvider}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{recordWrite} \PYG{o}{=} \PYG{n}{QgsFeature}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{recordWrite}\PYG{o}{.}\PYG{n}{setAttributes}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{recordWrite}\PYG{o}{.}\PYG{n}{setGeometry}\PYG{p}{(}\PYG{n}{QgsGeometry}\PYG{o}{.}\PYG{n}{fromWkt}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{POINT (1 1)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{providerSingle}\PYG{o}{.}\PYG{n}{addFeature}\PYG{p}{(}\PYG{n}{recordWrite}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{geomTypeQGIS}.png}
\caption{The Geometry subtype hierarchy employed by QGIS by default for several data providers.}\label{\detokenize{concept:id54}}\label{\detokenize{concept:figuregeomtypeii}}\end{figure}

QGIS mixes the primitive geometry types with the modern geometry types by default.  The data providers typically handle this well, but, the pre-scripted decisions can have consequences.

For example, by default QGIS will permit a user to add a Multline feature to a MicroS


\subsubsection{Empty and nulls}
\label{\detokenize{concept:empty-and-nulls}}

\subsection{GIS Centric And the Wall of Mystery}
\label{\detokenize{concept:gis-centric-and-the-wall-of-mystery}}

\subsection{Vector Datasets in GIS}
\label{\detokenize{concept:vector-datasets-in-gis}}
GIS refers to all of the components that are required to construct a Geographic Information System.  Every GIS system
needs components to store and retrieve spatial information and components to view and edit spatial information.

Spatial information is normally classified by whether it is a set of shapes referred to as a vector dataset or a
rectangular grid of values referred to as a raster dataset.  Here we are only concerned with vector datasets.

To facilitate storage and retrieval, an individual vector dataset is restricted to shapes and their attributes for a
specific subject.  To achieve utility, it is essential that the data type and range of valid values for each attribute is defined.  The prescription of data types and value ranges is referred to as schema.   For example, many GIS systems impose that a vector dataset may only contain one type of shape (e.g. point, line or polygon) and one shape object per record.  A dataset that has a defined schema is by definition a database.

In many organisations, the geospatial vector datasets are located within enterprise databases that have one or more data types that are specific to storing geospatial shapes.  An enterprise database refers to any database where multiple users may query or edit the same dataset at the same time.  Consequently, the set of shape values available needs to be consistent with the database design, and, these often include null and empty values.

Much of the GIS community work with the schema  restriction of a single geometry attribute data set.  It is difficult
to have multiple geometry attributes without also allowing empty geometry attributes.  Next, I will examine the
advantages and disadvantages of multiple geometry attributes.

The fundamental advantage of multiple geometry attributes is they facilitate topology. Topology refers to how the
constituent parts of a system are interrelated or arranged.  The location of points within squares shown schematically
in \sphinxcode{\sphinxupquote{figureI}} is an example of topology as it shows how the points are related to squares.  \hyperref[\detokenize{concept:tableiii}]{Table \ref{\detokenize{concept:tableiii}}} shows the topological
association of point type by square type, but, uses two geometry columns to do so.  \hyperref[\detokenize{concept:tablev}]{Table \ref{\detokenize{concept:tablev}}} shows the same data as
\hyperref[\detokenize{concept:tableiii}]{Table \ref{\detokenize{concept:tableiii}}} using only one geometry column.  Examination of \hyperref[\detokenize{concept:tablev}]{Table \ref{\detokenize{concept:tablev}}} reveals that the relationship between a type of point (e.g. Blue Crosses) and the Square type (e.g. Left Square or Right Square) has to be reported as two separate
relationships (two separate records) and a user is left with the task of mentally connecting these two relationships.  Clearly, without using multiple geometry columns showing topological relationships is less intuitive.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Another way to represent the data in \hyperref[\detokenize{concept:tableiii}]{Table \ref{\detokenize{concept:tableiii}}} that uses only one geometry column.}\label{\detokenize{concept:id55}}\label{\detokenize{concept:tablev}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Square
&\sphinxstyletheadfamily 
Point type
\\
\hline
Left square
&
Blue crosses \(\{P1,\ P2\}\)
\\
\hline\sphinxmultirow{2}{5}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{2}}
Left square
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{6}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{2}}
Red circles \(\{P3\}\)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
\\
\sphinxtablestrut{5}&\sphinxtablestrut{6}\\
\hline
Right square
&
Blue crosses \(\{P4\}\)
\\
\hline\sphinxmultirow{2}{9}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{2}}
Red circles
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{10}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{2}}
red circles \(\{empty\}\)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
\\
\sphinxtablestrut{9}&\sphinxtablestrut{10}\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The major disadvantage of multiple geometry columns is that they are not supported by many pieces of GIS software or GIS file formats.  For example, ArcGIS does not support multiple geometry columns in any capacity, QGIS treats each geometry column as an unrelated dataset, and, the ubiquitous shapefile can only contain one geometry column.  So, by adopting multiple geometry columns you are isolating yourself from a large portion of the GIS community.

Many GIS software packages force the user to perform a selection whenever they perform a set operation like a union,
intersection or difference.  The results of an intersection without a selection of the points and squares shown in
\sphinxcode{\sphinxupquote{figureI}} includes those records that don’t intersect (\hyperref[\detokenize{concept:tablev}]{Table \ref{\detokenize{concept:tablev}}}).  To achieve the more common output shown in
\hyperref[\detokenize{concept:tablevi}]{Table \ref{\detokenize{concept:tablevi}}} a selection must be performed on the data to include only those records that do intersect.  Hence, the logic
performed by most GIS software packages including ArcGIS and QGIS is: 1. Select those records where intersect is True; 2. Perform intersection.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Another way to represent the data in 5 where records where no intersection occurs are also shown.}\label{\detokenize{concept:id56}}\label{\detokenize{concept:tablevi}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Square
&\sphinxstyletheadfamily 
Point type
\\
\hline
Left square
&
Blue crosses \(\{P1,\ P2\}\)
\\
\hline\sphinxmultirow{2}{5}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{2}}
Left square
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{6}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{2}}
Red circles \(\{P3\}\)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
\\
\sphinxtablestrut{5}&\sphinxtablestrut{6}\\
\hline
Right square
&
Blue crosses \(\{P4\}\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Being forced to do a selection in addition to an intersection is an algorithmic solution that eliminates the need for empty geometry values.  Forcing a selection as part of a set operation introduces the assumption that records missing from the results are empty (e.g. do not intersect) and hence prohibits the ability to also record unknown (\sphinxstyleemphasis{null}) set operations.  Another problem of forced selection is that problem solving of erroneous set operations is hindered as one needs to undertake additional steps to confirm those records that were explicitly excluded by the forced selection.  For logic and critical thinking analysing the negative results can be more fruitful than analysing the positive results!


\subsection{QGIS}
\label{\detokenize{concept:qgis}}
QGIS is self-promoted as an “Open Source Geographic Information System” \sphinxcite{concept:id39}.  QGIS is used for creating, manipulating and publishing spatial data sets by many organisations.  Some organisations use QGIS to edit or create geometries for geospatial datasets within enterprise databases in their native format as no commercial software has this capability.  For example, \sphinxhref{http://www.smec.com/en\_au/what-we-do/sectors/transport/pavement-management-systems}{SMEC Pavement Management Software} uses a Microsoft SQL database to contain it’s pavement datasets.  QGIS can browse and edit the geometries contained within this dataset without importing or exporting any dataset.   In comparison, software like ArcMap requires a user to import, edit, then export the data to the SMEC Pavement Management Software even though both installation could have their data respective datasets within the same Microsoft SQL Server installation, and, both datasets are using the same datatype for the geometry values.
By intentional design and function, the majority of QGIS users use other software packages or software formats developed by other organisations to store geospatial datasets.  For example, the PostGIS, MS SQL and SpatiaLite databases, and, the esri shapefile format are all processed in their native format by QGIS.


\subsubsection{QGIS history}
\label{\detokenize{concept:qgis-history}}
QGIS was created by Gary Sherman in 2002 \sphinxcite{concept:qgiscontributors}\sphinxcite{concept:garysherman2011}.  In 2007 it became a project of the Open Source Geospatial Foundation with version 1 being released in January 2009 \sphinxcite{concept:qgiscontributors}.  The version of QGIS used in this project, Version 3, was released in February 2018 \sphinxcite{concept:qgiscontributors}.  Version 2 of QGIS employed Python 2 for scripting and PyQT4 for the graphical user interface (GUI).  Version 3 of QGIS employs Python 3 for scripting and PyQT5 for the GUI.  QGIS version 3 is self-described as a “huge overhaul and cleanup” of QGIS version 2 \sphinxcite{concept:qgischangelogv3}.  Many of the python scripts configured for version 2 no longer work with version 3 with much of the legacy sub-version support dropped.


\subsubsection{Vector datasets within QGIS}
\label{\detokenize{concept:vector-datasets-within-qgis}}
Within QGIS, the geometries for each record are contained within instances of QgsAbstractGeometry subclasses \sphinxcite{concept:qgsgeometryclass}.  The manner in which QGIS stores empty geometries is not inherited from the QgsAbstractGeometry superclass, but rather is determined for each subclass separately.  Although QGIS is capable to parse empty geometries for the majority of the QgsAbstractGeometry subclass there may be some that are unable to do so.

The variations in how QgsAbstractGeometry subclasses contain empty geometries is demonstrated in the following section by example.  Using the QGIS API, empty geometries for several geometry types can be instantiated by instantiating the relevant QgsAbstractGeometry subclass without a set of vertices.  For example, to test that a \sphinxcode{\sphinxupquote{QgsLineString()}} is empty:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{qgis.core} \PYG{k+kn}{import} \PYG{n}{QgsLineString}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{QgsLineString}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{isEmpty}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

Although empty geometries can be created for most geometry types with the QGIS API by instantiation without a set of vertices, it is not currently possible to instantiate an empty point geometry (\hyperref[\detokenize{concept:tablevii}]{Table \ref{\detokenize{concept:tablevii}}}). As demonstated below, the well known text representation of the call to instantiate an empty point reveals that QGIS is wrongly adding a vertex with the coordinates of \((0\ 0)\) \sphinxcite{concept:qgspointbugreport2018} %
\begin{footnote}[1]\sphinxAtStartFootnote
a \sphinxcode{\sphinxupquote{Point (nan nan)}} is also reported when an empty PostGis point is parsed by QGIS.
%
\end{footnote}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{qgis.core} \PYG{k+kn}{import} \PYG{n}{QgsLineString}\PYG{p}{,}\PYG{n}{QgsPoint}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{QgsLineString}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{asWkt}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{LineString ()}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{QgsPoint}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{asWkt}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{Point (0 0)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{QgsPoint}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{createEmptyWithSameType}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{asWkt}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{Point (nan nan)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Testing whether an empty geometry has been created by the instantiation of various types of QgsAbstractGeometry subclasses using the python Console in QGIS 3.0.3.}\label{\detokenize{concept:id57}}\label{\detokenize{concept:tablevii}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Input
&\sphinxstyletheadfamily 
Output
\\
\hline
\sphinxcode{\sphinxupquote{QgsPoint().isEmpty()}}
&
\sphinxcode{\sphinxupquote{False}}
\\
\hline
\sphinxcode{\sphinxupquote{QgsLineString().isEmpty()}}
&
\sphinxcode{\sphinxupquote{True}}
\\
\hline
\sphinxcode{\sphinxupquote{QgsPolygon().isEmpty()}}
&
\sphinxcode{\sphinxupquote{True}}
\\
\hline
\sphinxcode{\sphinxupquote{QgsGeometryCollection().isEmpty()}}
&
\sphinxcode{\sphinxupquote{True}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{PROBLEM DEFINITION}
\label{\detokenize{concept:problem-definition}}
The problems that this project intends to address are:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Null and empty shapes are parsed differently by different data providers in QGIS.

\item {} 
Within QGIS, there is no published plugin or output that shows records within a dataset that have null or empty geometry values.

\item {} 
Many GIS professionals do not anticipate or are aware of datasets that have null or empty geometries.

\item {} 
Empty geometry values were not included in the set of valid values in the original QGIS or GDAL specifications.

\end{enumerate}


\subsection{PARSING OF NULL AND EMPTY SHAPES TO AND FROM EXTERNAL DATABASES BY QGIS}
\label{\detokenize{concept:parsing-of-null-and-empty-shapes-to-and-from-external-databases-by-qgis}}
Using source specific data providers, QGIS processes data to and from third party databases without requiring constraints or additional tables in the third-party database.  Each data provider has been created independently and these do treat the same data values differently.  For example, as expected QGIS parses empty linestrings from PostGis databases as not null but it incorrectly parses empty linestrings from Microsoft SQL Server as null \sphinxcite{concept:parseemptyfromsql}.


\subsubsection{QGIS Data Providers}
\label{\detokenize{concept:qgis-data-providers}}
A component of software that allows it to directly read data without conversion to a different data type, and, to write updates or new records to a dataset without exporting is called a data provider.   QGIS contains data providers for 18 different formats for which it can read from or write to in their native format \sphinxcite{concept:qgsproviders2018}.  Being open source, each of the data QGIS providers were created at different times for different purposes, are founded on different philosophies and have different levels of development.  Consequently, even when different database packages follow the same geospatial standards, equivalent shapes from those different database packages may be read as different shapes due to variations or errors between data providers.

Within this project it is anticipated that errors passing empty or null values from Microsoft SQL Server or PostGIS will be found.  Unfortunately, the C++ classes employed in the data type specific data providers \sphinxcite{concept:qgsproviders2018} are not exposed in the QGIS API which means that their function is not easily modified.

QGIS’s data providers that allow it to read or write in native format without need for additional constraints or data tables is a key feature that makes it popular in large organisations. By reading and writing in the native format, QGIS can edit or create geospatial data within an enterprise database that is configured for another piece of software and without importing and exporting.  In doing so QGIS has removed one of the barriers to integration of geospatial data within enterprise datasets.

In comparison to QGIS’s approach of editing the data in it’s native format, ESRI’s ArcMap requires a user to import into a geodatabase and undertake the editing there\textendash{} even though the enterprise database and the geodatabase may be using the same database server \sphinxcite{concept:arcgistutorialforempty}.  ESRI’s approach often leads to a lookup table being used for geospatial data and then scripts run on those lookup tables to publish an integrated dataset.


\subsection{EXPOSURE OF NULL AND EMPTY SHAPE VALUES IN QGIS}
\label{\detokenize{concept:exposure-of-null-and-empty-shape-values-in-qgis}}
Within QGIS, without using custom expressions or scripts there is only limited exposure to null shapes, and, empty shapes.  Two locations within QGIS where you may find descriptive information of each record are the \sphinxstyleemphasis{“Attribute Table”} and the \sphinxstyleemphasis{“DB Manager”} plugin.

Without using expressions and creating new attributes, the “Attribute Table” does not contain any information about the record’s shapes.  The only component of the “Attribute Table” that exposes empty or null geometries is when a user selects “Zoom to Feature” for a specific record.  In QGIS version 3.x, a warning message is shown on the map canvas that the shape is empty or doesn’t exist depending on whether the shape is empty or \sphinxstyleemphasis{null} (\hyperref[\detokenize{concept:figureiii}]{Fig.\@ \ref{\detokenize{concept:figureiii}}}).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{FigureII}.png}
\caption{A warning message is displayed in QGIS when a user attempts to zoom to a record with an empty geometry.}\label{\detokenize{concept:id58}}\label{\detokenize{concept:figureiii}}\end{figure}

The DB Manager in QGIS 3.x is a core plugin (it can’t be uninstalled).  The DB Manager plugin provides database specific information for data from a limited number of databases that includes PostGIS, but, excludes Microsoft SQL Server.  The Table view within DB Manager shows all of the columns within the table including the geometry attribute.  For the geometry column it gives the geometry type and exposes null shapes as \sphinxstyleemphasis{“NULL”} (\hyperref[\detokenize{concept:figureiv}]{Fig.\@ \ref{\detokenize{concept:figureiv}}}).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{FigureIII}.png}
\caption{The output from the DB Manager plugin in QGIS 3.x for a dataset that contains both empty geometry values and null geometry values.}\label{\detokenize{concept:id59}}\label{\detokenize{concept:figureiv}}\end{figure}


\subsection{GIS PROFESSIONAL AWARENESS}
\label{\detokenize{concept:gis-professional-awareness}}
Many GIS professionals are educated and work within GIS dataset schema where both null and empty geometries are excluded.  It is plausible that GIS professionals that are not familiar with null and empty shapes are ignorant of them when using a GIS where they are permitted.  This is a situation that confronted the proponent of this project.  Examples of wrong understanding of null and empty geometry values are widespread on the world wide web.  For example, an article published by esri incorrectly states that an empty geometry exists for any geometry where the coordinates are unknown \sphinxcite{concept:esrinulloracle}.

Micosoft SQL and PostGis both permit null and empty geometry values unless explicitly excluded by constraints or third party software.  Even when a primary dataset contains no null or empty geometry values, processing of that dataset may produce empty null or empty geometry values.  Performing set operations like intersections within the database, and, editing geometry of specific records within QGIS are two ways empty geometry values can be created.


\subsubsection{Set operations in Microsoft SQL or PostGIS can produce empty geometry values}
\label{\detokenize{concept:set-operations-in-microsoft-sql-or-postgis-can-produce-empty-geometry-values}}
There are several fundamental set operations that are used to construct new sets from existing sets regardless to what it is a set of \sphinxcite{concept:settheoryoverall}.  Within a database, a set operation needs to be consistent for all data types.  As introduced in section \DUrole{xref,std,std-ref}{Records with false Boolean logic} some databases generate empty geometry values for set operations.  Microsoft SQL Server and PostGis are examples of databases that can generate empty geometry values for set operations.  Both of these databases developed from SQL conventions and their generation of empty values for geometries is consistent with set operations for other data types.

Intersection of two sets is an example of a set operation.  Intersect refers to those locations where two or more objects meet, cross or cover each other \sphinxcite{concept:intersectdefinition}.  Many different fields that employ set theory, Intersect of two datasets returns all records that exist in both datasets (\hyperref[\detokenize{concept:figurev}]{Fig.\@ \ref{\detokenize{concept:figurev}}}).  The intersect concept can be applied to many datatypes including characters, numbers, dates, and, geometries.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{FigureIV}.png}
\caption{The schematic intersection of Set 1 and Set 2 is purple.}\label{\detokenize{concept:id60}}\label{\detokenize{concept:figurev}}\end{figure}

Consider the intersection of the points ‘Pt1’ and ‘Pt2’ with the circle shown in \hyperref[\detokenize{concept:figurevi}]{Fig.\@ \ref{\detokenize{concept:figurevi}}} which is an example of an intersection between two geometry datasets.  ‘Pt 1’ lies within the circle, and, hence intersects the circle.  ‘Pt2’ lies outside the circle and does not.  In both QGIS v3.x and ArcGIS desktop, the intersection of a points dataset containing ‘Pt1’ and ‘Pt2’ and a dataset containing the circle will return only those records that intersect, hence, only ‘Pt1’ is returned.  In contrast, in Microsoft SQL Server, the intersection returns both the records that do and don’t intersect with a dataset containing both ‘Pt1’ and ‘Pt2’.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{FigureV}.png}
\caption{A schematic of the intersection of points ‘Pt1’ and ‘Pt2’ with a circle.}\label{\detokenize{concept:id61}}\label{\detokenize{concept:figurevi}}\end{figure}

There is no error with either the approach to intersection taken by QGIS 3.x and Microsoft SQL Server.  As described in the section \DUrole{xref,std,std-ref}{Records with false Boolean logic} QGIS 3.x includes an addition selection logic step that removes those records that don’t intersect.  For ‘Pt2’, Microsoft SQL server is returning an empty geometry confirming that no intersection exists, as shown by the following Transact-SQL script %
\begin{footnote}[2]\sphinxAtStartFootnote
In both Microsoft SQL and PostGis the geometry type that is empty is recorded \sphinxcite{concept:loskot2010}\sphinxcite{concept:ramsey2010}).  Sometimes the geometry type gets changed to the generic ‘GEOMETRYCOLLECTION’ by set operations.
%
\end{footnote}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DECLARE} \PYG{n+nd}{@circle} \PYG{n}{geometry} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CURVEPOLYGON (CIRCULARSTRING (0 1, 1 2, 2 1, 1 0, 0 1))}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{DECLARE} \PYG{n+nd}{@Pt2} \PYG{n}{geometry} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{POINT (3 1)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{SELECT} \PYG{n+nd}{@Pt2}\PYG{o}{.}\PYG{n}{STIntersection}\PYG{p}{(}\PYG{n+nd}{@circle}\PYG{p}{)}\PYG{o}{.}\PYG{n}{ToString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{GEOMETRYCOLLECTION} \PYG{n}{EMPTY}
\end{sphinxVerbatim}

This intersection example shows the ease with which one can inadvertently generate empty geometry values in Microsoft SQL Server, and, these empty geometry values will be passed to QGIS.


\subsubsection{Inadvertently Creating Empty Geometries within QGIS}
\label{\detokenize{concept:inadvertently-creating-empty-geometries-within-qgis}}
Within QGIS, an empty geometry is created by using the “Vertex Tool” to delete all vertices of an existing shape.  A user unfamiliar with QGIS may incorrectly assume that deleting all the vertices of a shape also deletes the record.  Hence, when editing a shape, a QGIS user may unintentionally create an empty shape when they are attempting to delete the shape.


\subsection{Retrospective incorporation of empty and null values into Software}
\label{\detokenize{concept:retrospective-incorporation-of-empty-and-null-values-into-software}}
The Geospatial Data Abstraction Library (GDAL) is ubiquitous within most GIS Software to translate and process geospatial data.  Handles for empty shapes were not part of the original GDAL specification, with empty shapes being treated as null.   The retrospective incorporation of empty handles into GDAL has not been picked up by many applications that employ GDAL, and, even within GDAL there are many processing tools that do not allow for empty shapes.

Many of the current GDAL set operators continue to convert empty geometry values to null geometry values even when the set being operated on has successfully implemented the empty shape handle on passing to GDAL.  For example, for the Intersection operation the output is \sphinxstyleemphasis{“a new geometry representing the intersection or NULL if there is no intersection or an error occurs”} \sphinxcite{concept:gdalintersection}.  Curiously, the same GDAL geometry class has a handle to assign an empty geometry, or, to test for an empty geometry \sphinxcite{concept:gdalempty}.  On another GDAL ticket register it is stated \sphinxstyleemphasis{“GML/WFS: by default does not advertise NOT NULL fields since we treat empty strings as being null for historical reasons. By setting the open option EMPTY\_AS\_NULL=NO, empty strings will be reported as such and NOT NULL fields might be advertised”} \sphinxcite{concept:rouault2015}, it is clear that GDAL is not originally intended to distinguish between null and empty.

The retrospective addition of handles for empty geometry values in GDAL was mimicked by QGIS.  Consequently, within QGIS there are likely to many set operators that convert empty values to null values as part of the set operation.


\subsubsection{The definition of Null and Empty Values depends on context}
\label{\detokenize{concept:the-definition-of-null-and-empty-values-depends-on-context}}
The definition of Empty geometry values introduced in section 2.2 it was articulated that an Empty geometry is just one valid value in the set of valid values for the geometry data type.  In contrast, null indicates that the geometry value is unknown and that the value can be any value from the set of valid values. Hence, an empty geometry values is one of many possible values for a null geometry (or, empty is a subclass of null).  For example, for a point, the vertices of an empty point are \(\{\ \ \}\) as it has no coordinates, and, the vertices of a null point are \(\{x,y\}\) where \(x\) and \(y\) are both variables designating unknown coordinates. These definitions are consistent with SQL relational databases.  Unfortunately, the definition of null used by SQL relational databases is different to that used by both mathematics for set theory, and, but most computer programming languages \sphinxcite{concept:whatisnull}.

Let’s consider the definition of null for set theory and computer programming using a common example.  If one has a box of apples and a box of bananas, then the intersection of the two boxes of fruit is an empty box. For set theory, \sphinxstyleemphasis{null} \textendash{} nothing is what you have when you take away the box.

Similar to set theory, for most object-oriented computer programming languages, an object that has not been instantiated is \sphinxstyleemphasis{null}.  Hence, a pointer to something that doesn’t exist is null. An empty object is an object that has been instantiated but not populated, for example, a list with no members, or, a box with no fruit.

So, from the perspective of an object-oriented computer programming language, null means no value.  Hence, a null object is an object that does not exist, or, occupies no space in a computer’s memory.  Indeed, SQL relational databases implement null as an object that doesn’t exist, so, the context difference between unknown and nothing does not have to create conflict.

The underlying conflict is based on logical deduction.  It has been proved that an empty set is a subset of any set.  It is argued that on object that doesn’t exist can’t contain anything, so, it must be empty %
\begin{footnote}[3]\sphinxAtStartFootnote
Unable to find a high quality reference for this argument.  Several private conversations with C++ programers reveal that this logic is common and is frequently used to test for empty in C++.
%
\end{footnote}.  Hence, \sphinxstyleemphasis{null} is a subclass of empty.  However, an empty set is a still a set, a container that is empty.  In contrast, null states that no container exists.  So, by arguing that a \sphinxstyleemphasis{null} object is empty you have just created an object.  A \sphinxstyleemphasis{null} object neither contains anything nor has a container.

Unfortunately, QGIS employs the logic that a null geometry is also an empty geometry \sphinxcite{concept:qgsgeometrysource2018}.    The QGIS test for null simply asks where there the object point points to anything \sphinxcite{concept:qgsgeometrysource2018}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
144 bool QgsGeometry::isNull() const
145 \PYGZob{}
146  return !d\PYGZhy{}\PYGZgt{}geometry;
147 \PYGZcb{}
\end{sphinxVerbatim}

Now, the QGIS test for empty performs the same test as for null, and, returns true if the test for null returns true \sphinxcite{concept:qgsgeometrysource2018}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
329 bool QgsGeometry::isEmpty() const
330 \PYGZob{}
331  if ( !d\PYGZhy{}\PYGZgt{}geometry )
332  \PYGZob{}
333  return true;
334  \PYGZcb{}
335
336  return d\PYGZhy{}\PYGZgt{}geometry\PYGZhy{}\PYGZgt{}isEmpty();
337 \PYGZcb{}
\end{sphinxVerbatim}


\section{Future Development}
\label{\detokenize{concept:future-development}}
Some ideas for improvement:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Add a summary table

\item {} 
Add a column for number of parts

\item {} 
Distinguish curved shapes

\item {} 
Distinguish shapes with elevation information

\end{enumerate}


\section{Bibliography}
\label{\detokenize{concept:bibliography}}



\chapter{Changelog}
\label{\detokenize{changelog:changelog}}\label{\detokenize{changelog::doc}}
All notable changes to this project will be documented in this file.

This project adheres to \sphinxhref{https://semver.org/spec/v2.0.0.html}{Semantic Versioning}.


\section{Version 0.1.0}
\label{\detokenize{changelog:version-0-1-0}}\begin{itemize}
\item {} 
First release

\item {} 
Shows attribute table for vector layers in QGIS v3.x with icons that represent the geometry.

\item {} 
Has the option to create demonstration vector datasets.

\end{itemize}


\section{Version 0.1.1}
\label{\detokenize{changelog:version-0-1-1}}\begin{itemize}
\item {} 
Removes the virtual field called ‘Geometry’ when the geomAttribute Attribute table is closed.

\end{itemize}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{sphinxthebibliography}{10}
\bibitem[1]{concept:gdalempty}
Empty(self, *args). URL: \sphinxurl{http://gdal.org/python/osgeo.ogr.Geometry-class.html\#Empty}.
\bibitem[2]{concept:esrinulloracle}
How To : Insert a NULL or empty st \_ geometry attribute in Oracle. URL: \sphinxurl{https://support.esri.com/en/technical-article/000010466}.
\bibitem[3]{concept:id39}
QGIS - The Leading Open Source Desktop GIS. URL: \sphinxurl{https://www.qgis.org/en/site/about/index.html\#}.
\bibitem[4]{concept:gdalintersection}
def Intersection(self, *args):. URL: \sphinxurl{http://gdal.org/python/osgeo.ogr-pysrc.html\#Geometry.Intersection}.
\bibitem[5]{concept:iso19125-2}
ISO 19125-2 Geographic information - Simple feature access. Part 2: SQL Option. First Edition. 2004.
\bibitem[6]{concept:whatisnull}
What Is Null. 2010. URL: \sphinxurl{http://wiki.c2.com/?WhatIsNull}.
\bibitem[7]{concept:qgsgeometryclass}
QgsGeometry Class Reference. 2017. URL: \sphinxurl{https://qgis.org/api/2.18/classQgsGeometry.html\#details}.
\bibitem[8]{concept:qgspointbugreport2018}
Bug report \#19190: QgsPoint class does not store empty point geometries - QGIS Application - QGIS Issue Tracking. 2018. URL: \sphinxurl{https://issues.qgis.org/issues/19190}.
\bibitem[9]{concept:qgischangelogv3}
Changelog for QGIS 3.0. 2018. URL: \sphinxurl{https://www.qgis.org/en/site/forusers/visualchangelog30/}.
\bibitem[10]{concept:intersectdefinition}
INTERSECT \textbar{} meaning in the Cambridge English Dictionary. 2018. URL: \sphinxurl{https://dictionary.cambridge.org/dictionary/english/intersect}.
\bibitem[11]{concept:qgsgeometrysource2018}
QGIS API Documentation: /tmp/buildd/qgis-3.3.0+git20180710+2688a9d+15buster/src/core/geometry/qgsgeometry.cpp Source File. 2018. URL: \sphinxurl{https://qgis.org/api/qgsgeometry\_8cpp\_source.html}.
\bibitem[12]{concept:qgsabstractgeometry}
QGIS API Documentation: QgsAbstractGeometry Class Reference. 2018. URL: \sphinxurl{https://qgis.org/api/classQgsAbstractGeometry.html}.
\bibitem[13]{concept:qgsproviders2018}
QGIS/src/providers/. 2018. URL: \sphinxurl{https://github.com/qgis/QGIS/tree/master/src/providers}.
\bibitem[14]{concept:arcgistutorialforempty}
Tutorial: Perform web editing using data from a database—Documentation \textbar{} ArcGIS Enterprise. 2018. URL: \sphinxurl{http://enterprise.arcgis.com/en/server/latest/get-started/windows/tutorial-performing-web-editing-using-data-from-a-database.htm}.
\bibitem[15]{concept:qgiscontributors}
Wikipeday Contributors. QGIS. URL: \sphinxurl{https://en.wikipedia.org/wiki/QGIS}.
\bibitem[16]{concept:settheoryoverall}
Wikipedia Contributors. Set (mathematics). 2018. URL: \sphinxurl{https://en.wikipedia.org/w/index.php?title=Set\_(mathematics)\&oldid=866126059}.
\bibitem[17]{concept:loskot2010}
Mateusz Loskot. SqlGeometry and POINT EMPTY in WKB. 2010. URL: \sphinxurl{http://mateusz.loskot.net/post/2010/02/26/sqlgeometry-and-point-empty-in-wkb/}.
\bibitem[18]{concept:ogc2010}
OGC. OpenGIS\textbackslash{}textregistered  Implementation Standard for Geographic information - Simple feature access - Part 1: Common architecture. \sphinxstyleemphasis{Open Geospatial Consortium, Inc}, pages 93, 2010. URL: \sphinxurl{http://portal.opengeospatial.org/files/?artifact\_id=25355E+Implementation+Standard+for+Geographic+information+-+Simple+feature+access\#1}.
\bibitem[19]{concept:ramsey2010}
Paul Ramsey. Nothing, Nada, Zip, Bupkus. 2010. URL: \sphinxurl{http://blog.cleverelephant.ca/2010/03/nothing-nada-zip-bupkus.html}.
\bibitem[20]{concept:rouault2015}
Even Rouault. Empty elements in GML : empty or NULL. 2015. URL: \sphinxurl{https://trac.osgeo.org/gdal/ticket/5968}.
\bibitem[21]{concept:garysherman2011}
Gary Sherman. History of QGIS Committers. 2011. URL: \sphinxurl{http://spatialgalaxy.net/2011/09/23/history-of-qgis-committers/}.
\bibitem[22]{concept:parseemptyfromsql}
Philip Whitten. Bug report \#19397: Parssing of empty geometry values from MicroSoft SQL Server - QGIS Application - QGIS Issue Tracking. 2018. URL: \sphinxurl{https://issues.qgis.org/issues/19397}.
\end{sphinxthebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{m}
\item\relax\sphinxstyleindexentry{modelVectorLayers}\sphinxstyleindexpageref{API:\detokenize{module-modelVectorLayers}}
\indexspace
\bigletter{p}
\item\relax\sphinxstyleindexentry{parseQGISGeometry}\sphinxstyleindexpageref{API:\detokenize{module-parseQGISGeometry}}
\indexspace
\bigletter{z}
\item\relax\sphinxstyleindexentry{zipGeomAttribute}\sphinxstyleindexpageref{API:\detokenize{module-zipGeomAttribute}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}